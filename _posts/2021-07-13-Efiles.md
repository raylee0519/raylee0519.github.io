---
layout: single
title: "C# 프로그래밍 4번째 시간 - 연산자"
categories:
  - C# Study
---

## 유니티의 네걸음, C# 공부시작 22일차

오늘은 C#에서 기본적이지만 매우 중요한 ***연산자***에 대해서 배우겠습니다! <br><br>

### 1.수식 연산자 (+, -, *, /, %)

덧셈, 뺄셈, 곱셈, 나눗셈, 그리고 나머지를 구하는 연산자가 있습니다. 이것을 표로 정리해보겠습니다.

분류|기능|예시
---|---|---
+ |양쪽 피연산자를 서로 더한다|a + b
- |왼쪽 피연산자에서 오른쪽 피연산자를 뺀다|a - b
* |양쪽 피연산자를 서로 곱한다|a * b
/ |왼쪽 피연산자를 오른쪽 피연산자로 나눈다|a / b
% |왼쪽 피연산자를 오른쪽 피연산자로 나눈 뒤의 나머지를 구한다|a % b

피연산자는 연산의 대상을 의미합니다. a+b에서 a,b는 피연산자, +는 연산자입니다.

수식연산자를 이용해서 예제를 만들어보겠습니다.

#### [수식 연산자를 활용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 55, b = 4;
			Console.WriteLine("{0} + {1} = {2}", a, b, a + b);
			Console.WriteLine("{0} - {1} = {2}", a, b, a - b);
			Console.WriteLine("{0} * {1} = {2}", a, b, a * b);
			Console.WriteLine("{0} / {1} = {2}", a, b, a / b);
			Console.WriteLine("{0} % {1} = {2}", a, b, a % b);
		}
	}
} 
```

이에 대한 결과는 <br>
55 + 4 = 59 <br>
55 - 4 = 51 <br>
55 * 4 = 220 <br>
55 / 4 = 13 <br>
55 % 4 = 3 <br>
가 나올것입니다.
 
 
 
진짜 말 그대로 기본적인 연산을 해주는 것입니다. 여기서 궁금증이 발생하는데, <br>

왜 55에서 4를 나눴을때의 값은 13.75가 아니라 13만 출력될까요? <br>

프로그래밍에서는 정수 간의 나눗셈은 항상 정수로만 표시됩니다. <br>

이에 따라 a,b가 int여서 발생한 현상인데, 이 둘 중 하나만 실수 타입(float,double,decimal)로 변환해주면 소수점도 출력가능합니다. <br>
 
여기서 a,b 중 하나를 실수타입으로 초기화해도 되지만,
이를 간단하게 만드려면 
```
Console.WriteLine("{0} / {1} = {2}", a, b, a / (double)b);
Console.WriteLine("{0} / {1} = {2}", a, b, (a + 0.0) / b);
Console.WriteLine("{0} / {1} = {2}", a, b, 1.0 * a / b);
 ```

이런 방식을 이용해도 됩니다.

### 2.수식 연산자 (++, --)

증감연산자는 피연산자의 값을 1 증가시키거나 1 감소시키는 증가 감소 연산자가 있습니다.

분류|기능|예시
---|---|---
++ (전위 증가 연산자) |피연산자의 값을 1만큼 증가|++a;
-- (전위 감소 연산자) |피연산자의 값을 1만큼 감소|--a;
++ (후위 증가 연산자) |피연산자의 값을 1만큼 증가|a++;
-- (후위 감소 연산자) |피연산자의 값을 1만큼 감소|a--;

이 표를 활용하여 증감연산자를 사용한 예제를 만들어보겠습니다.

#### [증감연산자를 이용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 1;
			Console.WriteLine(++a); // a의 값을 1 증가시키고, a의 값을 출력 (a = 2)
			Console.WriteLine(a++); // a의 값을 출력한 뒤, a의 값을 1 증가 (a = 3)
			Console.WriteLine(--a); // a의 값을 1 감소시키고, a의 값을 출력 (a = 2)
			Console.WriteLine(a--); // a의 값을 출력한 뒤, a의 값을 1 감소 (a = 1)
			}
	}
}
  ```
  
이에 따른 결과는 

2 2 2 2 가 나옵니다.

*전위* 라고 붙은 연산자는 피연산자의 값을 먼저 증가, 감소하고 문장을 실행합니다.

반대로 *후위* 라고 붙은 연산자는 문장을 먼저 실행시키고 뒤에서 값을 증가하고 감소합니다.
<br>
 

증감연산자를 처음보면 어려울 수 있어서 추가 예시를 하나 들어보겠습니다.

ex) a => 2, b => 3일때, 연산식의 결과를 생각해봅시다.
```
1. (a++) + b

2. (a++) + (- -b)

3. (++a) + (a++)
```
(1) 답은 5입니다. a에서 후위 증가 연산자를 이용하여 계산이 끝나고 a의 값이 증가합니다.

즉, 출력을 할때는 a의 값의 증가를 처리하기 전입니다. 따라서 2+3=5로 나옵니다.

(2) 답은 4입니다. a에서 후위 증가 연산자를 이용하였고, b는 전위 감소 연산자를 이용하여,

출력을 하기전 b는 계산이 되고, a는 계산되지 않았습니다. 따라서 2+2=4로 나옵니다.

(3) 답은 6입니다. 맨 처음에 a에서 전위 증가 연산자를 이용하여 출력하기 전에 계산이 됩니다.

근데, 다음 a에서는 이미 앞에 a가 +1된 형태이기 때문에 그 형태에서 후위 증가 연산자를 작용합니다.

당연히, 후위 연산자이므로 최종적으로 출력될때는 계산되지 않습니다.

따라서 3+3=6으로 나옵니다.

<br>
<br>


### 3.관계 연산자 (<, >, ==, !=, >=, <=)
말 그대로 관계를 알아보는 연산자입니다. 여기서는 크기를 비교하고, 값이 같은지 다른지 확인합니다.

이를 표로 정리해보겠습니다.

분류|기능|예시
---|---|---
< |오른쪽 피연산자가 왼쪽 피연산자보다 크면 참, 작으면 거짓|a < b
> |왼쪽 피연산자가 오른쪽 피연산자보다 크면 참, 작으면 거짓|a > b
== |왼쪽 피연산자가 오른쪽 피연산자와 같으면 참, 작으면 거짓|a == b
!= |왼쪽 피연산자가 오른쪽 피연산자와 다르면 참, 작으면 거짓|a != b
>= |왼쪽 피연산자가 오른쪽 피연산자보다 크거나 같으면 참, 작으면 거짓|a >= b
<= |오른쪽 피연산자가 왼쪽 피연산자보다 크거나 같으면 참, 작으면 거짓|a <= b                                      

관계 연산자를 사용하여 예제를 만들어보겠습니다.
#### [관계 연산자를 활용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 50, b = 60;
			Console.WriteLine(a < b); // 50 < 60, True
			Console.WriteLine(a > b); // 50 > 60, False
			Console.WriteLine(a == b); // 50 == 60, False
			Console.WriteLine(a != b); // 50 != 60, True
			Console.WriteLine(a >= b); // 50 >= 60, False
			Console.WriteLine(a <= b); // 50 <= 60, True
			}
	}
}
```
 
이에 따른 결과는 <br>
True <br>
False <br>
False <br>
True <br>
False <br>
True

* 관계 연산자의 결과는 반드시 참(True) 혹은 거짓(False)입니다. 
<br>
<br>

### 4.할당 연산자 (=, +=, -=, *=, /=, %=)

이 연산자는 오른쪽 피연산자를 왼쪽 피연산자에서 할당하는 역할을 합니다. 말이 어려운데, 표를 보면서 이해하겠습니다.

분류|기능|예시
---|---|---
= |오른쪽 피연산자를 왼쪽 피연산자에 할당|a = b;
+= |a += b는 a = a + b와 같음|a += b;
-= |a -= b는 a = a - b와 같음|a -= b;
*= |a *= b는 a = a * b와 같음|a *= b;
/= |a /= b는 a = a / b와 같음|a /= b;
%= |a %= b는 a = a % b와 같음|a %= b;

이를 이용하여 일단 예제를 만들어보겠습니다.

#### [할당 연산자를 활용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 50, b = 60;
			a += b;
			Console.WriteLine(a);
			a -= b;
			Console.WriteLine(a);
			a *= b;
			Console.WriteLine(a);
			a /= b;
			Console.WriteLine(a);
			a %= b;
			Console.WriteLine(a);
		}
	}
}
```
이에 따른 결과는
110 
50
3000
50
50
입니다.

예를 들어, a+=b에서, a+b=110인데, 이를 a에 넣겠다는 겁니다. 즉, 오른쪽에서 먼저 계산을 마치고, <br>
계산을 마친 값을 앞의 피연산자 즉, a에게 넣은겁니다. <br>
따라서 모두 a를 출력했는데, 나오는 값이 다 다른 것입니다. 
<br>
<br>

### 5.논리 연산자 (&&,||,!)
논리 연산자는 앞의 관계 연산자처럼 값이 true 또는 false로 출력이 되는 연산자입니다.
여기서 쓰는 종류에는 논리곱(AND),논리합(OR),부정(NOT)이 있습니다. <br>
표를 보겠습니다. <br>

<논리곱 연산자(&&)의 진리표>
 A       | B       | A && B  
---------|---------|---------
 참(T)   | 참(T)   | 참(T)   
 참(T)   | 거짓(F) | 거짓(F) 
 거짓(F) | 참(T)   | 거짓(F) 
 거짓(F) | 거짓(F) | 거짓(F) 

논리곱 연산자 특징으로는 A와 B가 모두 참이어야 결과값으로 참이 나옵니다. <br>

<논리합 연산자(||)의 진리표>
 A       | B       | A || B  
---------|---------|---------
 참(T)   | 참(T)   | 참(T)   
 참(T)   | 거짓(F) | 참(T)
 거짓(F) | 참(T)   | 참(T) 
 거짓(F) | 거짓(F) | 거짓(F) 

논리합 연산자 특징으로는 A나 B 둘 중 하나라도 참이면 결과값으로 참이 나옵니다. <br>

<부정 연산자(!)의 진리표>
 A       | !A       
---------|---------
 참(T)   | 거짓(F)   
 거짓(F)   | 참(T) 

부정 연산자 특징으로는 A가 참일때는 거짓, 거짓일때는 참을 출력합니다. <br>

이를 활용해서 예제를 만들겠습니다.

#### [논리 연산자를 사용한 예제]
```c#
using System;
namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 50, b = 60;
			Console.WriteLine(a > 40 && b > 50);
			Console.WriteLine(a > 40 || b > 70);
			Console.WriteLine(!(a < b));
			}
	}
} 
```
이에 따른 결과로, <br>
True <br>
True <br>
False <br>
가 나옵니다.

첫번째 True는 a>40과 b>50 논리가 모두 참이어서 결과로 참이 출력되었고, <br>
두번째 True는 a>40 논리가 거짓이지만 b>70 논리가 참이어서 결과로 참이 출력됩니다. <br>
세번째 False는 원래 a<b 논리가 참이지만, 부정연산자로, 결과를 부정하여 거짓으로 출력합니다. <br>

#### 6.비트 연산자
말 그대로 비트를 다루는 연산자입니다. 비트에 대한 내용은 차후 **조각지식모음**에서 다루겠습니다.
 분류 | 기능                                                    | 예     
------|---------------------------------------------------------|--------
 &    | 두 피연산자의 대응되는 비트에 논리곱(AND)을 수행        | a & b  
 \|   | 두 피연산자의 대응되는 비트에 논리합(OR)을 수행         | a \| b 
 ^    | 두 피연산자의 대응되는 비트에 배타적 논리합(XOR)을 수행 | a ^ b  

일단 비트는 기본적으로 0과 1이 있습니다. 이를 이용하는 연산자인데, <br>
&연산자는 양쪽 비트가 1이어야 결과가 1이 되고, 그러지 않으면 0이 됩니다. <br>
\|연산자는 양쪽 비트 중 하나라도 1이면 결과가 1이 됩니다. <br>
^연산자는 양쪽 비트가 서로 달라야 결과가 1이 됩니다. <br>
예제를 만들어보겠습니다.
 
#### [비트 연산자를 이용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 5, b = 10;
			Console.WriteLine(a & b);
			Console.WriteLine(a | b);
			Console.WriteLine(a ^ b);
		}
	}
}
```

이에 따른 결과는
0
15
15
이 나옵니다.

기본적으로 2진수를 쓰기 때문에 발생하는 현상입니다. 이에 대해서는 차후에 자세히 다루겠습니다.
<br>
<br>
### 7.시프트 연산자

이 연산자도 비트와 관련된 연산자인데, 첫번째 피연산자를 두번째 피연산자로 지정된 비트 수만큼 왼쪽(<<)으로 이동하거나 오른쪽으로(>>)으로 이동시킬 수 있습니다.

이를 이용하여 예제를 만들어보겠습니다.

#### [시프트 연산자를 활용한 예제]
```c#
using System;

namespace ConsoleApplication
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 616;
			Console.WriteLine(a << 4);
			Console.WriteLine(a >> 4);
		}
	}
}
```

결과로, <br>
9856 <br>
38
가 나옵니다.

616는 2진수로 하면 1001101000(2)입니다. 이 비트열을 왼쪽으로 4만큼 이동시키면

10011010000000(2)이 됩니다. 이걸 다시 10진수로 만들면 9856이 됩니다. 

왼쪽으로 비트열을 이동시키면 뒤에 있는 비트들은 모두 0으로 채워집니다.

 

이를 다시 오른쪽으로 4만큼 이동시키면 100110(2)이 되고, 이를 10진수로 만들면 38이 됩니다.

본래가지고 있는 비트열에서 오른쪽으로 가면, 열을 넘어가게 되는데, 넘어가는 부분들은 버려집니다.

그리고 새로 나타나는 앞 부분 비트들은 부호 비트로 채워집니다.

(부호 비트로는 양수가 0, 음수가 1 입니다.)

### 마무리하며
오늘은 연산자에 대한 대부분의 내용들을 배웠는데, 내용을 정리할 필요가 나을 것 같아서 표를 많이 활용하였습니다.
다음시간에는 조건문인 if,else,switch문을 배워보도록 하겠습니다.
